{% extends "base.html" %}
{% load static %}

{% block title %}Traffic Control Dashboard{% endblock %}

{% block content %}
<div class="container-fluid">
  <h2 class="text-center mb-4">ðŸš¦ Smart Traffic Control Dashboard</h2>
  <div class="d-flex justify-content-end mb-3 align-items-center">
    <label class="me-2 fw-bold">Traffic Mode:</label>
    <select class="form-select w-auto" id="trafficModeToggle">
      <option value="normal" {% if mode == "normal" %}selected{% endif %}>Normal</option>
      <option value="peak" {% if mode == "peak" %}selected{% endif %}>Peak</option>
    </select>
  </div>

  <!-- Tabs -->
  <ul class="nav nav-tabs" id="dashboardTabs" role="tablist">
    <li class="nav-item"><button class="nav-link active" data-bs-toggle="tab" data-bs-target="#predictedQueue">Predicted Queue</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#mlPerformance">ML Model Performance</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#signalState">Signal State</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#flowStats">Flow Stats</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#historicalLogs">Historical Logs</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#syncOverview">Synchronization Overview</button></li>
  </ul>

  <div class="tab-content mt-4">
    <!-- Predicted Queue -->
    <div class="tab-pane fade show active" id="predictedQueue">
      <h5>Predicted Queue per Intersection (EMA + ML)</h5>
      <canvas id="queueChart" height="180"></canvas>
    </div>

    <!-- ML Model Performance -->
    <div class="tab-pane fade" id="mlPerformance">
      <h5>ML Training Metrics (MAE & RÂ²)</h5>
      <canvas id="metricsChart" height="120"></canvas>
    </div>

    <!-- Signal State -->
    <div class="tab-pane fade" id="signalState">
      <h5>Live Signal States</h5>
      <table class="table table-striped text-center align-middle mt-3" id="signalStateTable">
        <thead class="table-primary">
          <tr>
            <th>Intersection</th>
            <th>Direction</th>
            <th>Signal State</th>
            <th>Remaining Time (s)</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <!-- Flow Stats -->
    <div class="tab-pane fade" id="flowStats">
      <h5>Vehicle Flow per Intersection</h5>
      <table class="table table-bordered text-center align-middle mt-3" id="flowStatsTable">
        <thead class="table-success">
          <tr>
            <th>Intersection</th>
            <th>Vehicles Passed</th>
            <th>Avg Queue Length</th>
            <th>Last Updated</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <!-- Historical Logs -->
    <div class="tab-pane fade" id="historicalLogs">
      <h5>Recent Signal Cycle History</h5>
      <canvas id="historicalChart" height="180"></canvas>
    </div>

    <!-- Synchronization Overview -->
    <div class="tab-pane fade" id="syncOverview">
      <h5 class="mt-3">Synchronization Overview (Offsets relative to master)</h5>
      <div class="row mt-2">
        <div class="col-md-6">
          <div id="sync-table-container" class="table-responsive"></div>
        </div>
        <div class="col-md-6">
          <canvas id="syncOffsetChart" height="300"></canvas>
        </div>
      </div>
    </div>
  </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
// ==========================
// Global
// ==========================
let queueChart, metricsChart, historicalChart;
let selectedMode = "{{ mode }}";

// Mode toggle
document.getElementById("trafficModeToggle").addEventListener("change", (e) => {
  selectedMode = e.target.value;
  fetchAllData();
});

// ==========================
// Fetch All Data
// ==========================
function fetchAllData() {
  fetch("{% url 'dashboard_data_api' %}?mode=" + selectedMode)
    .then(r => r.json())
    .then(data => updateQueueChart(data.predictions, data.ml_predictions, data.ema_predictions));

  fetch("{% url 'training_metrics_api' %}?mode=" + selectedMode)
    .then(r => r.json())
    .then(data => updateMetricsChart(data));

  fetch("{% url 'signal_state' %}?mode=" + selectedMode)
    .then(r => r.json())
    .then(data => updateSignalStateTable(data));

  fetch("{% url 'flow_stats' %}?mode=" + selectedMode)
    .then(r => r.json())
    .then(data => updateFlowStatsTable(data));

  fetch("{% url 'historical_logs' %}?mode=" + selectedMode)
    .then(r => r.json())
    .then(data => updateHistoricalChart(data));

  loadSyncOverview();
}

// ==========================
// Predicted Queue Chart (EMA + ML)
// ==========================
function updateQueueChart(predictions) {
    const ctx = document.getElementById('queueChart').getContext('2d');
    if (queueChart) queueChart.destroy();

    const directions = ["N", "E", "S", "W"];
    const lanes = ["straight", "left", "right"];
    const labels = [];

    // Build X-axis labels with spacing between directions
    directions.forEach(dir => {
        lanes.forEach(lane => {
            labels.push(`${dir}-${lane}`);
        });
        labels.push(''); // empty label as visual gap between directions
    });

    const intersections = Object.keys(predictions);
    const intersectionColors = [
        "#007bff", "#28a745", "#ffc107", "#dc3545",
        "#6f42c1", "#17a2b8", "#fd7e14", "#20c997"
    ];

    const datasets = intersections.map((inter, idx) => {
        // Map predictions to X-axis labels
        const data = labels.map(label => {
            return label && predictions[inter][label] ? predictions[inter][label] : 0;
        });

        return {
            label: inter,
            data: data,
            backgroundColor: intersectionColors[idx % intersectionColors.length],
            borderColor: "#000",
            borderWidth: 1
        };
    });

    queueChart = new Chart(ctx, {
        type: 'bar',
        data: { labels, datasets },
        options: {
            responsive: true,
            plugins: {
                legend: { position: 'bottom', labels: { boxWidth: 18, padding: 8 } },
                tooltip: {
                    callbacks: {
                        label: function(ctx) {
                            const lane = ctx.label || '';
                            return `${ctx.dataset.label} - ${lane}: ${ctx.raw}`;
                        }
                    }
                }
            },
            scales: {
                x: {
                    stacked: false,
                    title: { display: true, text: "Direction + Lane" },
                    ticks: { maxRotation: 45, minRotation: 30 }
                },
                y: {
                    beginAtZero: true,
                    title: { display: true, text: "Predicted Queue Length" }
                }
            }
        }
    });
}


// ==========================
// Signal State Table (soft colors)
// ==========================
function updateSignalStateTable(data) {
  const tbody = document.querySelector("#signalStateTable tbody");
  tbody.innerHTML = "";
  Object.entries(data).forEach(([inter, dirs]) => {
    Object.entries(dirs).forEach(([dir, info]) => {
      const bgColor = info.state === 'green' ? 'rgba(144,238,144,0.4)' : 'rgba(255,182,193,0.4)';
      tbody.innerHTML += `
        <tr style="background-color:${bgColor}">
          <td>${inter}</td>
          <td>${dir}</td>
          <td><strong>${info.state.toUpperCase()}</strong></td>
          <td>${info.remaining_time}</td>
        </tr>`;
    });
  });
}

// ==========================
// Flow Stats
// ==========================
function updateFlowStatsTable(data) {
  const tbody = document.querySelector("#flowStatsTable tbody");
  tbody.innerHTML = "";
  Object.entries(data).forEach(([inter, stats]) => {
    tbody.innerHTML += `
      <tr>
        <td>${inter}</td>
        <td>${stats.vehicles_passed}</td>
        <td>${stats.avg_queue_length}</td>
        <td>${new Date(stats.timestamp).toLocaleTimeString()}</td>
      </tr>`;
  });
}

// ==========================
// ML Metrics Chart
// ==========================
function updateMetricsChart(data) {
  const ctx = document.getElementById('metricsChart').getContext('2d');
  if (metricsChart) metricsChart.destroy();

  metricsChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: data.timestamps,
      datasets: [
        { label: 'MAE', data: data.mae, borderColor: 'red', borderWidth: 2, fill: false },
        { label: 'RÂ²', data: data.r2, borderColor: 'green', borderWidth: 2, fill: false }
      ]
    },
    options: { responsive: true, scales: { y: { beginAtZero: true } }, plugins: { legend: { position: 'bottom' } } }
  });
}

// ==========================
// Historical Chart
// ==========================
function updateHistoricalChart(data) {
  const ctx = document.getElementById('historicalChart').getContext('2d');
  if (historicalChart) historicalChart.destroy();

  const labels = data.map(e => e.timestamp);
  const greenTimes = data.map(e => e.green_time);

  historicalChart = new Chart(ctx, {
    type: 'line',
    data: { labels, datasets: [{ label: 'Green Time (s)', data: greenTimes, borderColor: '#007bff', borderWidth: 2, fill: false }] },
    options: { responsive: true, plugins: { legend: { position: 'bottom' } } }
  });
}

// ==========================
// Synchronization Overview
// ==========================
async function loadSyncOverview() {
  try {
    const res = await fetch("{% url 'sync_status' %}");
    if (!res.ok) throw new Error('Sync API error');
    const payload = await res.json();

    // Table
    const tableContainer = document.getElementById('sync-table-container');
    let html = '';
    payload.groups.forEach(group => {
      html += `<h6 class="mt-2">${group.name} (master: ${group.master})</h6>`;
      html += `<table class="table table-sm table-bordered"><thead><tr>
        <th>Intersection</th><th>Exists</th><th>Distance (m)</th><th>Travel Time (s)</th><th>Offset (s)</th>
      </tr></thead><tbody>`;
      group.rows.forEach(r => {
        html += `<tr>
          <td>${r.intersection}</td>
          <td>${r.exists ? 'âœ“' : 'â€”'}</td>
          <td>${r.distance_m}</td>
          <td>${r.travel_time_s !== null ? r.travel_time_s : 'â€”'}</td>
          <td>${r.offset_s !== null ? r.offset_s : 'â€”'}</td>
        </tr>`;
      });
      html += `</tbody></table>`;
    });
    tableContainer.innerHTML = html;

    // Offset Chart
    const labels = [];
    const data = [];
    const bg = [];
    payload.groups.forEach((group, gi) => {
      group.rows.forEach(r => {
        labels.push(`${group.name}: ${r.intersection}`);
        data.push(r.offset_s || 0);
        const hue = (gi * 80) % 360;
        bg.push(`hsl(${hue} 70% 60% / 0.85)`);
      });
    });

    const ctx = document.getElementById('syncOffsetChart').getContext('2d');
    if (window.syncOffsetChart) {
      window.syncOffsetChart.data.labels = labels;
      window.syncOffsetChart.data.datasets[0].data = data;
      window.syncOffsetChart.data.datasets[0].backgroundColor = bg;
      window.syncOffsetChart.update();
    } else {
      window.syncOffsetChart = new Chart(ctx, {
        type: 'bar',
        data: { labels, datasets: [{ label: 'Offset (s)', data, backgroundColor: bg }] },
        options: {
          indexAxis: 'y',
          responsive: true,
          scales: { x: { title: { display: true, text: 'Offset (s) relative to master' }, ticks: { beginAtZero: true } } },
          plugins: { tooltip: { callbacks: { label: ctx => ` ${ctx.parsed.x} s` } } }
        }
      });
    }
  } catch (err) { console.error("Failed to load sync overview:", err); }
}

// ==========================
// Initial Load & Refresh
// ==========================
document.addEventListener('DOMContentLoaded', () => {
  fetchAllData();
  setInterval(fetchAllData, 10000);
  setInterval(loadSyncOverview, 30000);
});
</script>
{% endblock %}
